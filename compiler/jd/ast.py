#!/bin/python
"""
ast.py

classes used to generate the abstract syntax tree (generated by parser)

Copyright 2014, University of Toronto

Report bugs to kuei.sun@utoronto.ca
"""

import cStringIO

class Type(object):
    """
    Type of object or its fields
    """
    QUALIFIERS = ( "const", "volatile", "long", "short", "unsigned", "signed" )
    USER_DEFINED = ( "struct", "union", "enum" )
    
    def __init__(self, input):
        """
        Initialize through a list of specifiers and qualifiers or a single
        specifier
        """
        if not isinstance(input, list):
            spec_qual_list = [ input, ]
        else:
            spec_qual_list = input
        self.qualifiers = list()
        self.specifier = None
        self.ident = None
        for token in spec_qual_list:
            self.append(token)
    
    @property
    def full_name(self):
        name = " ".join(self.qualifiers)
        if self.specifier is None:
            return name
        elif name == "":
            return self.specifier
        else:
            return "%s %s"%(name, self.specifier)
    
    def _append_type(self, token):
        for tok in token.qualifiers:
            self.append(tok)
        if self.specifier is None:
            self.specifier = token.specifier
        elif token.specifier is not None:
            raise AttributeError
    
    def _append_str(self, token):
        if token in Type.QUALIFIERS:
            self.qualifiers.append(token)
        else:
            if self.specifier is None:
                self.specifier = token
            else:
                raise AttributeError
            if token.startswith(Type.USER_DEFINED):
                word = token.split(" ")
                self.aggregate = word[0]
                if len(word) > 1:
                    self.ident = word[1]   
    
    def append(self, token):
        if isinstance(token, Type):
            self._append_type(token)
        elif isinstance(token, str):
            self._append_str(token)
        elif token is None:
            pass
        else:
            raise NotImplementedError
            
    def __repr__(self):
        return 'Type("%s")'%self.full_name
    
    def __str__(self):
        return self.full_name
        
    def __radd__(self, other):
        self.append(other)
        return self
        
    def __add__(self, other):
        return self.__radd__(other)
        

class Inner(Type):
    """
    Aggregate variable class (union or struct)
    
    We currently do not allow struct-level annotations on inner structs
    """
    next_id = 1
    @classmethod
    def generate_id(cls):
        id = cls.next_id
        cls.next_id += 1
        return id
    
    def __init__(self, spec_qual_list, fields=[]):
        super(Inner, self).__init__(spec_qual_list)
        self.id = Inner.generate_id()
        self.fields = fields
        for field in fields:
            field.parent = self
            if isinstance(field.type, Inner):
                field.type.parent = self
        
    def __str__(self):
        output = cStringIO.StringIO()
        output.write(self.full_name)
        output.write(" {\n")
        for field in self.fields:
            output.write("  ")
            output.write(str(field).replace("\n", "\n  "))
            output.write(";\n")
        output.write("}")
        content = output.getvalue()
        output.close()
        return content

class Field(object):
    """
    Base field class
    """
    def __init__(self, name, _type, annos, lineno):
        self.name = name
        self.type = _type
        self.lineno = lineno
        self.annos = annos
        for anno in annos:
            anno.parent = self
    
    def __str__(self):
        output = cStringIO.StringIO()
        for anno in self.annos:
            output.write("%s\n"%str(anno))
        output.write("%s %s"%(self.type, self.name))
        content = output.getvalue()
        output.close()
        return content
        
    def __repr__(self):
        return '%s("%s")'%(type(self).__name__, self.name)
        
    def __getitem__(self, idx):
        return self.annos[idx]
        
    def __eq__(self, other):
        if hasattr(other, 'name'):
            # special case: anonymous nested classes
            if isinstance(self.type, Inner) and self.name == "":
                return False
            return self.name == other.name
        return False

class Scalar(Field):
    """
    Scalar field class
    """
    def __init__(self, name, _type, annos=[], lineno=0):
        super(Scalar, self).__init__(name, _type, annos, lineno)

class Array(Field):
    """
    Array field class
    """
    
    def __str__(self):
        output = cStringIO.StringIO()
        output.write(super(Array, self).__str__())
        for size in self.sizes:
            output.write("[%s]"%size)
        content = output.getvalue()    
        output.close()
        return content
    
    def __init__(self, name, _type, sizes, annos=[], lineno=0):
        """
        size is actually a C expression
        """
        super(Array, self).__init__(name, _type, annos, lineno)
        self.sizes = sizes

class Token(object):
    """
    Turns dictionary into object
    """
    def __init__(self, **entries): 
        self.__dict__.update(entries)
        
    def __eq__(self, other):
        if hasattr(self, 'name') and hasattr(other, 'name'):
            return self.name == other.name
        else:
            return False
            
    def __str__(self):
        if hasattr(self, 'name'):
            return self.name
        else:
            return repr(self)

class Struct(object):
    """
    AST class for a jd struct
    """
    
    def __init__(self, name, fields=[], annos=[], alias=[], lineno=0):
        self.name = name
        self.annos = annos
        self.fields = fields
        self.alias = alias
        for anno in annos:
            anno.parent = self
        for field in fields:
            field.parent = self
            # (jsun): VECTOR annotation may be part of field
            if isinstance(field, Annotation):
                pass
            elif isinstance(field.type, Inner):
                field.type.parent = self
        self.lineno = lineno
        
    def size(self):
        output = cStringIO.StringIO()
        output.write("sizeof(struct %s)"%self.name)
        for field in self.fields:
            if hasattr(field, 'vector'):
                output.write(" + %s"%field.vector.size)
        content = output.getvalue()
        output.close()
        return content
        
    def __repr__(self):
        return 'Struct("%s")'%self.name
        
    def __str__(self):
        output = cStringIO.StringIO()
        if len(self.alias) > 0:
            output.write("typedef ")
        output.write(str(self.annos[0]))
        if len(self.name) > 0:
            output.write(" ")
            output.write(self.name)
        output.write(" {\n")
        for field in self.fields:
            output.write("  ")
            output.write(str(field).replace("\n", "\n  "))
            output.write(";\n")
        for anno in self.annos[1:]:
            output.write("  %s\n"%str(anno))
        output.write("}")
        if len(self.alias) > 0:
            output.write(" ")
            output.write(", ".join(self.alias))
        output.write(";")
        content = output.getvalue()
        output.close()
        return content
        
    def __getitem__(self, idx):
        return self.fields[idx]

class Enum(object):
    """
    AST class for enumerated types
    """
    def __init__(self, name, elements, anno, alias=[], lineno=0):
        self.name = name
        self.elements = elements
        self.anno = anno
        self.alias = alias
        anno.parent = self
        for element in elements:
            element.parent = self
        
    def __repr__(self):
        return 'Enum("%s")'%self.name
        
    def __str__(self):
        output = cStringIO.StringIO()
        if len(self.alias) > 0:
            output.write("typedef ")
        output.write(str(self.anno))
        if len(self.name) > 0:
            output.write(" ")
            output.write(self.name)
        output.write(" {\n")
        for element in self.elements:
            output.write("  ")
            output.write(str(element).replace("\n", "\n  "))
            output.write(",\n")
        output.write("}")
        if len(self.alias) > 0:
            output.write(" ")
            output.write(", ".join(self.alias))
        output.write(";")
        content = output.getvalue()
        output.close()
        return content        

class Constant(object):
    """
    AST class for each enumerated value
    """
    def __init__(self, name, value=None, lineno=0):
        self.name = name
        self.value = value
        self.lineno = lineno
        
    def __str__(self):
        if self.value is not None:
            return "%s = %s"%(self.name, self.value)
        else:
            return self.name
            
    def __repr__(self):
        return 'Constant(%s)'%self.name
        
    def __eq__(self, other):
        if isinstance(other, Constant):
            return self.name == other.name
        else:
            return False

class Annotation(object):
    """
    AST class for an annotation
    """
    GLOBAL = [ 'ADDRSPACE', 'VECTOR' ]
    STRUCT = [ 'VECTOR', 'CHECK', 'POINTER', 'FIELD' ]
    FIELD = [ 'POINTER', 'FIELD', ]
    
    def __init__(self, name, kvpair, num_semicolons=0, lineno=0):
        self.name = name
        self.args = dict(kvpair)
        self.num_semicolons = num_semicolons    # used to track syntax error
        self.lineno = lineno
        
    def __str__(self):
        output = cStringIO.StringIO()
        output.write("%s("%(self.name))
        output.write(",".join([
                     "%s=%s"%(k, v) for (k, v) in self.args.items()]))
        output.write(")")
        content = output.getvalue()
        output.close()
        return content
    
    def get(self, idx, default=None):
        return self.args.get(idx, default)
        
    def has(self, idx):
        return self.args.has_key(idx)
        
    def __getitem__(self, index):
        return self.args[index]

    def __repr__(self):
        return 'Annotation("%s")'%self.name
    
