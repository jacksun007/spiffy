/*
 * @( libsrc )
 *
 * @( fs.name ) library generated by jdc. Do NOT edit this file.
 *
 * Author: Kuei (Jack) Sun
 * E-mail: kuei.sun@mail.utoronto.ca
 *
 * University of Toronto
 * March 2016
 */

#include <@(libheader)>

@( fs.name )::@( fs.name )() : FS::FileSystem("@( fs.name )")
    , root_path(this) {}

@( fs.name )::@( fs.name )(FS::IO & io) : FS::FileSystem("@( fs.name )", io)
    , root_path(this) {}

@( fs.name )::~@( fs.name )() {}

FS::Container * @(fs.name)::parse_by_type(int type, FS::Location & loc, 
        FS::Path * path, const char * buf, unsigned len) const
{
    FS::Container * ret = nullptr;
    
    switch ( type )
    {
@[ for obj in fs.object_table ]
    case @( obj.typeid ):
        @[ if obj.is_vector_type() ]
        @[ if obj.container.is_extent() ]
        /* TODO: need a way to determine the block type of arbitrary offset *
         * within a heterogenous extent                                     */
        ret = nullptr;
        @[ else ]
        ret = @(obj.container.classname)::factory(loc, path, buf, len);
        @[ endif ]
        @[ elif obj == fs.root ]
        ret = parse_super(loc.offset, buf, len);
        @[ elif obj.rank == "container" ]
        ret = @(obj.container.classname)::factory(loc, path, buf, len);
        @[ else ]
        /* we only allow creation of containers */
        ret = nullptr;
        @[ endif ]
        break;
@[ endfor ]
    default:
        break;
    }
    
    return ret;
}

const char * @(fs.name)::type_to_name(unsigned type) const
{
    const char * ret = FS::FileSystem::type_to_name(type);
    
    if (ret != nullptr)
        return ret;

    switch (type)
    {
@[ for obj in fs.object_table ]
    case @( obj.typeid ):
        ret = "@( obj.typeid )";
        break;
@[ endfor ]
    default:
        ret = "CORRUPTED_TYPE_ID";
        break;
    }
    
    return ret;
}

const char * @(fs.name)::address_space_to_name(int aspc) const
{
    const char * ret = FS::FileSystem::address_space_to_name(aspc);
    
    if (ret != nullptr)
        return ret;
    
    switch (aspc)
    {
@[ for as in fs.new_address_spaces ]
    case @(as.enumname):
        ret = "@(as.name)";
        break;
@[ endfor ]
    default:
        ret = "unknown";
        break;    
    }
    
    return ret;
}

@[ with super = fs.root ]

FS::Container * 
@(fs.name)::parse_super(unsigned long start, const char * buf, unsigned len) const
{
    if ( start > @(super.location) )
        return nullptr;

    const long offset = @(super.location) - start;
    const long leftover = len - offset;
    
    if ( leftover < (long)sizeof(@(super.typename)) )
        return nullptr;
        
    FS::Location loc(FS::AS_BYTE, sizeof(@(super.typename)), 
        0, @(super.location));

    return @(super.classname)::factory(loc, &root_path, buf + offset, leftover);
}

FS::Container * @( fs.name )::fetch_super() const
{
    char * buf = nullptr;
    ssize_t retval;
    FS::Container * super = nullptr;
    FS::Location loc(FS::AS_BYTE, sizeof(@(super.typename)), 
        0, @(super.location));
     
    retval = this->io.read(loc, buf);
    if (retval >= 0 && buf != nullptr)
    {
        super = @(super.classname)::factory(loc, &root_path, buf, 
            sizeof(@(super.typename)));
        delete [] buf;
    }
    
    return super;
}

@[ endwith ]

FS::Container * @(fs.name)::create_container(int type, FS::Path * path) const
{
    /* TODO: make this work */
    return nullptr;
}

@[ for obj in fs.object_table ]

@[ include "metadata.cc" with context ]

@[ endfor ]

@[ for obj in fs.enums ]
const char * @(fs.name)::@(obj.classname)::enum_to_name(unsigned long val)
{
    switch (val)
    {
@[ for enu in obj.elements ]
    case @(enu.name):
        return "@(enu.name)";
        break;
@[ endfor ]
    default:
        break;
    }
    
    return nullptr;
}
@[ endfor ]

@[ for xref in fs.xrefs ]
@(fs.name)::@(xref.classname) @(fs.name)::@(fs.xrefname)::invalid_@(xref.xref);
@[ endfor ]

@(fs.name)::@(fs.xrefname)::@(fs.xrefname)(void)
    : FS::Path(nullptr)
@[ for xref in fs.xrefs ]    
    , @(xref.xref)(nullptr)
@[ endfor ]    
{}

@(fs.name)::@(fs.xrefname)::@(fs.xrefname)(const FS::Path * from) 
    : FS::Path((from == nullptr) ? nullptr : 
        const_cast<FS::FileSystem *>(from->get_file_system()))  
{
    if (from != nullptr) {
        const @(fs.xrefname) * xr = static_cast<const @(fs.xrefname) *>(from);
        @[ for xref in fs.xrefs ]
        this->@(xref.xref) = xr->@(xref.xref);
        this->@(xref.xref)->incref();
        @[ endfor ]
        (void)xr;
    }
    else {
        @[ for xref in fs.xrefs ]    
            this->@(xref.xref) = &invalid_@(xref.xref);
            this->@(xref.xref)->incref();
        @[ endfor ]  
    }
}

@(fs.name)::@(fs.xrefname)::@(fs.xrefname)(FS::FileSystem * fs) 
    : FS::Path(fs)  
{
@[ for xref in fs.xrefs ]    
    this->@(xref.xref) = &invalid_@(xref.xref);
    this->@(xref.xref)->incref();
@[ endfor ]  
}

@(fs.name)::@(fs.xrefname)::~@(fs.xrefname)()
{
    /* this avoids infinite recursion if there were self-reference */
    @[ for xref in fs.xrefs ]
    if (this->@(xref.xref) != nullptr) {
        const @(xref.classname) * @(xref.xref) = this->@(xref.xref);
        this->@(xref.xref) = nullptr;
        @(xref.xref)->decref();  
    } 
    @[ endfor ]    
}


