/*
 * @( fs.name ) library generated by jdc
 *
 * Author: Kuei (Jack) Sun
 * E-mail: kuei.sun@mail.utoronto.ca
 *
 * University of Toronto
 * 2015
 */

#ifndef LIB@( fs.name | upper )_H
#define LIB@( fs.name | upper )_H

@[ for file in headers ]
#include "@(file)"
@[ endfor ]
#include "libfs.h"

class @( fs.name ) final : public FS::FileSystem 
{           
public:
    @( fs.name )();
    @( fs.name )(FS::IO & io);
    virtual ~@( fs.name )() override;
    
    enum AddrSpace {
    @[ for as in fs.new_address_spaces ]
        @[ if loop.first ]
        @( as.enumname ) = FS::NUM_ADDRSPACES,
        @[ else ]
        @( as.enumname ),
        @[ endif ]
    @[ endfor ]
    }; 
    
    enum TypeId
    {
    @[ for obj in fs.object_table ]
        @[ if loop.first ]
        @( obj.typeid ) = FS::NUM_GENERIC_IDS,
        @[ else ]
        @( obj.typeid ),
        @[ endif ]
    @[ endfor ]    
    };
    
    virtual FS::Container * fetch_super() const override;
    virtual FS::Container * parse_super(unsigned long start, const char * buf, 
                                        unsigned len) const override;  
    virtual FS::Container * parse_by_type(int type, FS::Location & loc, 
        FS::Path * path, const char * buf, unsigned len) const override;
    virtual const char * type_to_name(unsigned type) const override;
    virtual const char * address_space_to_name(int aspc) const override;
    virtual FS::Container * create_container(int type, FS::Path * path) const override;

    virtual int super_type_id() const override
    {
        return @( fs.root.typeid );
    }

    @[ for obj in fs.enums ]
    struct @(obj.classname)
    {
        static const char * enum_to_name(unsigned long val);
    };
    @[ endfor ]

    @[ for obj in fs.forward_decl ]    
    class @(obj.classname);    
    @[ endfor ]
    
    @[ for xref in fs.xrefs ]
    class @(xref.classname);
    @[ endfor ]
    
    struct @(fs.xrefname) : public FS::Path
    {
        @[ for xref in fs.xrefs ]
        static @(xref.classname) invalid_@(xref.xref);
        @[ endfor ]
    
        @[ for xref in fs.xrefs ]
        const @(xref.classname) * @(xref.xref);
        @[ endfor ]
        
        @(fs.xrefname)(void);
        @(fs.xrefname)(FS::FileSystem * fs);
        @(fs.xrefname)(const FS::Path * from);
        virtual ~@(fs.xrefname)() override;
    };
    
    @[ for obj in fs.object_table ]
        @[ if obj.is_vector_type() ]
            @[ include "vector.h" with context ]
        @[ elif obj.is_extent() ]
#error "Extent structures are current not supported"
        @[ else ]
            @[ include "entity/object.h" with context ]
        @[ endif ]
    @[ endfor ]   
      
    @(fs.xrefname) root_path;
};

#endif /* LIB@( fs.name | upper )_H */
